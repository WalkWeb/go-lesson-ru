
# Изучаем язык Go #20 – Методы

Механика методов в Go реализована через привязывание [функций](https://github.com/WalkWeb/go-lesson-ru/tree/master/12_functions) 
к [структурам](https://github.com/WalkWeb/go-lesson-ru/tree/master/19_structs). Получая в сумме то, что можно считать
объектом: данные и связанные с ними методы.

Создадим структуру `rectangle`:

```
type rectangle struct {
    width, height int
}
```

И привяжем к ней два метода `area()` и `perimeter()`:

```
func (r rectangle) area() int {
    return r.width * r.height;
}

func (r rectangle) perimeter() int {
    return 2*r.width + 2*r.height;
}
```

Затем создадим структуру, т.е. объект (хотя, конечно, объекты в golang это отдельная дискуссионная тема, часть 
программистов скажет, что в go нет ООП, а то, что есть это какая-то фигня) от созданной структуры и обратимся к её 
методам:

```
    r := rectangle{10, 5}

    fmt.Println(r)
    fmt.Println("rectangle area:", r.area())
    fmt.Println("rectangle perimeter:", r.perimeter())
```

Выполнив написанный код получим:

```
{10 5}
rectangle area: 50
rectangle perimeter: 30
```

При этом методы могут работать со связанной структурой как просто с данными, так и как с 
[указателем](https://github.com/WalkWeb/go-lesson-ru/tree/master/17_pointers), в последнем случае все сделанные 
изменения в данных сохранятся.

Второй вариант делается через передачу структуры по указателю `func (r *rectangle)`, но для большей наглядности сделаем
отдельную структуру с отдельными методами. Создаем структуру `user`:

```
type user struct {
    name string
    year int
}
```

И добавляем два метода. Первый будет работать с данными:

```
func (u user) birthday_no_link() int {
    u.year = u.year + 1;
    return u.year
}
```

А второй с указателем:

```
func (u *user) birthday_link() int {
    u.year = u.year + 1;
    return u.year
}
```

И теперь на двух объектах посмотрим разницу:

```
    u1 := user{"Vasya", 30}

    fmt.Println(u1)
    fmt.Println(u1.birthday_no_link())
    fmt.Println(u1)

    u2 := user{"Masha", 50}

    fmt.Println(u2)
    fmt.Println(u2.birthday_link())
    fmt.Println(u2)
```

Выполнив код получим:

```
{Vasya 30}
31
{Vasya 30}
{Masha 50}
51
{Masha 51}
```

Что получаем:

- Метод `birthday_no_link()` хоть и изменяет внутри себя данные структуры `user`, изменяет это только в скопированной
версии данных для этого метода. Внешние данные это изменение никак не затрагивает.
- Метод `birthday_link` работает уже не с данными, а с указателем (ссылкой) на структуру (объект). По этому все 
внесенные изменения внутри метода сохраняются.

В заключение стоит добавить, почему объекты в Go реализованные именно так своеобразно: отдельно структуры, отдельно
функции, которые к этим структурам привязываются. Все дело в производительности: полноценная механика объектов, с 
наследованием, абстрактными методами и прочим – требует дополнительных ресурсов на обработку. Простые же функции
работают в несколько (иногда в десятки) раз быстрее. А Go это язык который изначально создавался под обработку большого
количества данных, т.е. под максимальную производительность.

____

В этом уроке вы узнали:

1. Как к структурам привязывать функции, получая тем самым объект с какими-то данными и с какими-то методами
