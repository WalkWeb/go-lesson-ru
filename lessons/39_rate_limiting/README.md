
# Изучаем язык Go #39 – Ограничение скорости

Иногда нужно не просто создать программу, которая будет обрабатывать какие-то данные, но написать её так, чтобы она 
особо не загружала ресурсы сервера, независимо от количества данных.

В golang это легко сделать используя [горутины](https://github.com/WalkWeb/go-lesson-ru/tree/master/lessons/25_goroutines), 
[каналы](https://github.com/WalkWeb/go-lesson-ru/tree/master/lessons/26_channels) и 
[тикеры](https://github.com/WalkWeb/go-lesson-ru/tree/master/lessons/36_tickers).

## Первый пример – простая задержка при обработке

Первый, простой пример, как ограничить нагрузку на ресурсы сервера – это добавление задержки перед обработкой каждого
сообщения.

Чтобы сэмулировать какой-то набор данных – создадим канал, заполним его данными, после чего закроем:

```
    requests := make(chan int, 15)

    for i := 0; i < 5; i++ {
        requests <- 1
    }

    close(requests)
```

Обработка данных с задержкой делается через простой тикер, который будет генерировать сообщение в канал с задержкой в
200 миллисекунд. А сама механика задержки происходит за счет особенности работ каналов, когда программа слушая канал не
замирает до тех пор, пока не будет получено сообщение в канале:

```
    limiter := time.Tick(200 * time.Millisecond)

    for req := range requests {
        <- limiter
        fmt.Println("request", req, time.Now())
    }
```

Выполнив этот код получим:

```
$ go run rate-limiting.go 
request 1 2022-07-23 14:45:56.239777277 +0300 MSK m=+0.200245254
request 1 2022-07-23 14:45:56.439752643 +0300 MSK m=+0.400220590
request 1 2022-07-23 14:45:56.639683194 +0300 MSK m=+0.600151131
request 1 2022-07-23 14:45:56.83972217 +0300 MSK m=+0.800190117
request 1 2022-07-23 14:45:57.039698699 +0300 MSK m=+1.000166626
```

## Второй пример – ограничение по объему запросов

Второй пример осуществляет более умное балансирование нагрузки. Объяснить это лучше на примере отвлеченном от 
программирования.

Представьте себе два отделения почты, каждое из которых может обслужить до 5 человек в час. Но в первом отделении все 
стоят в одной очереди и проходят по одному (на обслуживание каждого уходит 12 минут), а во втором могут обслуживать до 3 
человек одновременно, но также не более 5 в час.

Получается, что несмотря на общий лимит обслуженных в час, если во второе отделение придет 3 человека сразу, а потом час 
никто приходить не будет – то они даже не заметят, что есть какое-то ограничение по обслуживаемым людям в час.

Переходим к реализации.

Как и в первом примере, вначале эмулируем какой-то набор данных

```
    plosiveRequests := make(chan int, 5)

    for i := 0; i < 5; i++ {
        plosiveRequests <- i
    }

    close(plosiveRequests)
```

Лимит одновременно обработанных каналов будет осуществляться за счет отдельного канала с буферизацией в 3 сообщения.
Соответственно и лимит будет на 3 одновременно обработанных сообщения.

```
    plosiveLimiter := make(chan time.Time, 3)
```

Но общий лимит на 5 сообщений в секунду останется прежним, за счет тикера

```
    go func() {
        for t := range time.Tick(200 * time.Millisecond) {
            plosiveLimiter <- t
        }
    }()
```

И обработка самих сообщений аналогична первому примеру:

```
    for req := range plosiveRequests {
        <-plosiveLimiter
        fmt.Println("plosive request", req, time.Now())
    }
```

Выполнив этот код получим:

```
$ go run rate-limiting.go 
...
plosive request 0 2022-07-23 14:45:57.239841179 +0300 MSK m=+1.200309096
plosive request 1 2022-07-23 14:45:57.439941139 +0300 MSK m=+1.400409096
plosive request 2 2022-07-23 14:45:57.639819442 +0300 MSK m=+1.600287379
plosive request 3 2022-07-23 14:45:57.839850172 +0300 MSK m=+1.800318109
plosive request 4 2022-07-23 14:45:58.03986935 +0300 MSK m=+2.000337307
```

____

В этом уроке вы узнали:

1. Как организовать обработку данных с ограничением скорости через простую задержку после каждого сообщения
2. Как организовать обработку данных с ограничением скорости с более умной и параллельной обработкой
