
# Изучаем язык Go #31 – Timeouts

В уроке про [синхронизацию каналов](https://github.com/WalkWeb/go-lesson-ru/tree/master/lessons/28_channel_synchronization)
мы рассматривали пример, когда нам обязательно нужно дождаться ответа из канала, независимо от того, когда он будет.

Но иногда задача стоит противоположная – подождать ответа из канала фиксированное время, и если ответ не получен – 
завершить ожидание.

В сегодняшнем уроке мы рассмотрим как это сделать.

Создадим канал с [буферизацией](https://github.com/WalkWeb/go-lesson-ru/tree/master/lessons/27_channel_buffering) одного 
сообщения:

```
    c1 := make(chan string, 1)
```

Создаем горутину, которая с задержкой в 2 секунды отправляет в канал сообщение:

```
    go func() {
        time.Sleep(time.Second * 2)
        c1 <- "result 1"
    }()
```

И создадим конструкцию с `select` и `time.After` которая и будет осуществлять логику завершения ожидания получения
сообщения через 1 секунду:

```
    select {
        case res := <- c1:
            fmt.Println(res)
        case <- time.After(time.Second * 1):
            fmt.Println("timeout, ending")
    }
```

Выполнив этот код получим:

```
$ go run timeout.go 
timeout, ending
```

Т.е. за указанную секунду мы не получили сообщения из канала (потому что оно отправляется через 2 секунды), и `select`
завершил свою работу.

Теперь рассмотрим вариант, когда сообщение получается. Скопируйте написанный код и замените ожидание в `time.After` на
3 секунды (и нужно будет поправить мелочи вроде названия канала и выводимый результат):

```
    c2 := make(chan string, 1)
    go func() {
        time.Sleep(time.Second * 2)
        c2 <- "result 2"
    }()

    select {
        case res := <- c2:
            fmt.Println(res)
        case <- time.After(time.Second * 3):
            fmt.Println("timeout, ending")
    }
```

Выполнив этот код получим:

```
$ go run timeout.go 
timeout, ending
result 2
```

Первый `select` отработал как и прежде, не дождавшись сообщения, а второй получил сообщения, потому что ожидание 
увеличено до 3 секунд.

В завершение стоит добавить несколько деталей: если во втором варианте увеличить задержку до 100 секунд 
`time.After(time.Second * 100)` то код в любом случае завершится через 3 секунды: 1 секунду будет выполняться первый
`select` и 2 секунды второй. А указанная задержка в 100 секунд просто пропускается так как сообщение получено – очень
удобно.

Второй момент в том, что код будет работать точно также, если в каналах убрать буферизацию. Мы добавили её для 
страховки, на тот случай, чтобы код не был заблокирован даже в том случае, если слушателя канала не будет. Это 
распространенный подход.

____

В этом уроке вы узнали:

1. Как ограничивать время ожидания получения сообщения из канала.
