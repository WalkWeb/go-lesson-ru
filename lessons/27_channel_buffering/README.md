
# Изучаем язык Go #27 – Буферизация каналов

По-умолчанию отправить сообщение в канал можно только в том случае, если есть кто-то, кто принимает сообщения из этого
канала. Буферизация позволяет обойти это ограничение, и отправлять какое-то количество сообщений в канал даже в том 
случае, если в данный момент никто сообщения не принимает.

Создать канал с буферизацией легко, достаточно вторым аргументов в `make()` передать число – максимальное количество
буферизированных сообщений в данном канале:

```
    channel := make(chan string, 2)
```

Запишем в него 2 сообщения, а потом прочитаем их:

```
    channel <- "message 1"
    channel <- "message 2"

    fmt.Println(<- channel)
    fmt.Println(<- channel)
```

Выполнив этот код получим:

```
$ go run channel-buffering.go 
message 1
message 2
```

Обратите внимание, что с каналами с буферизацией можно работать в одной горутине (хоть мы её и не указываем, она 
создается по-умолчанию для выполнения функции `main()`).

Достаточно убрать буферизацию, и даже с одним сообщением код перестанет работать:

```
    channel := make(chan string)

    channel <- "message 1"

    fmt.Println(<- channel)
```

Выполнив этот код получим:

```
$ go run channel-buffering.go 
fatal error: all goroutines are asleep - deadlock!

goroutine 1 [chan send]:
main.main()
        /var/www/github_go/lessons/27_channels_buffering/channels-buffering.go:10 +0x59
exit status 2
```

Мы получили `deadlock` – отправка сообщения в канал заблокировала текущую горутину. Тоже самое произойдет, если мы 
попытаемся отправить третье сообщение в канал.

____

В этом уроке вы узнали:

1. Как добавлять буферизацию в каналы
