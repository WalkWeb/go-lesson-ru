
# Изучаем язык Go #35 – Timers

Иногда нужно выполнить какой-то код в будущем. Можно воспользоваться обычным `time.Sleep()`, но в Go есть более 
продвинутые решения: Timer и Ticker.

В этом уроке мы рассмотрим работу таймера (timer).

Таймер – это специальный канал, который вернет сообщение через указанный промежуток времени. Простейший пример 
использования:

```
    timer1 := time.NewTimer(2 * time.Second)

    <-timer1.C

    fmt.Println("Timer1 worked")
```

Выполнив этот код получим:

```
$ go run timers.go 
Timer1 worked
```

При этом строка `Timer1 worked` выведется через 2 секунды после запуска программы. На первый взгляд работа аналогична
простому `time.Sleep(time.Second * 2)`, но есть одно важное отличие: задержку сделанную на Timer можно пропустить.

Добавьте код ниже:

```
    timer2 := time.NewTimer(1 * time.Second)

    go func() {
       <-timer2.C
       fmt.Println("Timer2 worked")
    }()

    stop2 := timer2.Stop()
    if stop2 {
        fmt.Println("Timer2 stopped")
    }

    time.Sleep(3 * time.Second)
```

Здесь мы добавляем второй таймер, выполняем его в отдельной горутине, но тут же останавливаем его через вызов 
`timer2.Stop()`. При этом в конце делаем дополнительную задержку в 3 секунды, чтобы убедиться, что второй таймер не 
отработал.

Выполнив код получим:

```
$ go run timers.go 
Timer1 worked
Timer2 stopped
```

Первый таймер отработал как и раньше, а второй был остановлен.

При этом, если попробовать удалить задержку в конце – код после остановки второго таймера сразу завершится – никакой
задержки нет.

____

В этом уроке вы узнали:

1. Как использовать таймеры и в чем их преимущество над `time.Sleep()`
