
# Изучаем язык Go #33 – Закрытие каналов

Каналы закрываются через специальную встроенную функцию `close(channel)`, и на этом урок можно было и закончить, но у 
закрытия канала есть две особенности:
* канал отмечается как закрытый, и принимающая сторона может это проверить, и на основании этого изменить свою работу
* попытка получения сообщения из закрытого канала не блокирует горутину.

Рассмотрим на примере. Создадим канал, отправим в него 3 значения, и попробуем пройти про нему через цикл:

```
    jobs := make(chan int)

    jobs <- 1
    jobs <- 2
    jobs <- 3

    for {
        j, more := <-jobs
        fmt.Println(j)
        fmt.Println(more)
    }
```

Выполнив этот код получим ошибку:

```
$ go run closing_channels.go 
fatal error: all goroutines are asleep - deadlock!
```

Из-за чего она произошла? Банально из-за того, что отправка сообщения в канал без буферизации блокирует текущую горутину
`main()` до момента, пока кто-то сообщение не получит. А получателей нет.

Давайте добавим буферизацию в канале:

```
    jobs := make(chan int, 3)

    jobs <- 1
    jobs <- 2
    jobs <- 3

    for {
        j, more := <-jobs
        fmt.Println(j)
        fmt.Println(more)
    }
```

Выполнив этот код опять получим deadlock:

```
$ go run closing_channels.go 
1
true
2
true
3
true
fatal error: all goroutines are asleep - deadlock!
```

На этот раз из-за того, что горутину заблокировало получение 4 элемента из канала, которого нет и никогда не появится.

Давайте добавить горутину, чтобы получение сообщения не блокировало родительскую горутину `main()`:

```
    jobs := make(chan int, 3)

    jobs <- 1
    jobs <- 2
    jobs <- 3

    go func() {
        for {
            j, more := <-jobs
            fmt.Println(j)
            fmt.Println(more)
        }
    }()
```

Выполнив код получим... пустой вывод. Почему так произошло – потому что горутина не успев создаться была закрыта вместе
с отработавшей родительской горутиной `main()`.

Можно еще поэкспериментировать, убрать беферизацию и создать горутину перед отправкой сообщений:

```
    jobs := make(chan int)
    
    go func() {
        for {
            j, more := <-jobs
            fmt.Println(j)
            fmt.Println(more)
        }
    }()
    
    jobs <- 1
    jobs <- 2
    jobs <- 3
```

Выполнив этот код получим такой вариант:

```
$ go run closing_channels.go 
1
true
2
true
3
true
```

Или такой:

```
$ go run closing_channels.go 
1
true
2
true
```

Это происходит опять же из-за завершения работы горутины `main()`, и дочерняя горутина иногда успевает обработать все
три сообщения, а иногда не успевает. Согласитесь – плохая реализация программы, которая работает то так, то сяк.

Теперь вернемся к изначальному варианту и добавляем буферизацию плюс закрытие канала:

```
    jobs := make(chan int, 3)

    jobs <- 1
    jobs <- 2
    jobs <- 3

    close(jobs)

    for {
        j, more := <-jobs
        fmt.Println(j)
        fmt.Println(more)
    }
```

Выполнив этот код получим бесконечный цикл:

```
$ go run closing_channels.go 
1
true
2
true
3
true
0
false
0
false
0
```

Чтобы остановить программу нажмите `Ctrl+C`. Давайте разбираться что произошло. Бесконечный цикл получился из-за того, 
что цикл не знает, когда нужно остановиться. При этом, обратите внимание, что в цикле продолжаются делаться попытки
получить сообщение из закрытого канала, но к блокировке горутины это уже не приводит.

Теперь мы уже близко к желаемому результату. Осталось добавить логику проверки того, что канал закрылся. Обратите 
внимание на результат выполнения последнего запуска – пока канал не был закрыт, второе возвращаемое значение было true,
а потом стало false.

Соответственно нужно просто добавить проверку второго значения на false:

```
    for {
        j, more := <-jobs

        if (!more) {
            return
        }

        fmt.Println(j)
        fmt.Println(more)
    }
```

Выполнив этот код получим:

```
$ go run closing_channels.go 
1
true
2
true
3
true
```

Вот так, с помощью закрытия канала и проверки второго возвращаемого значения мы сделали корректную обработку всех 
сообщений в канале через `for`.

В заключение рассмотрим что произойдет, если в закрытый канал попробовать отправить сообщение:

```
    jobs := make(chan int, 3)

    jobs <- 1

    close(jobs)

    jobs <- 2
```

Выполнив этот код получим ошибку типа `panic`:

```
 go run closing_channels.go 
panic: send on closed channel
```

Стоит добавить, что в уроке полностью изменен код урона из оригинала на gobyexample.com, потому что на мой взгляд их 
пример никак не позволяет понять особенности закрытия каналов в Go.

____

В этом уроке вы узнали:

1. Как закрывать каналы и какие особенности это имеет
