
# Изучаем язык Go #17 – Указатели

Данные и указатели являются сложной темой для понимания новичками. В этом уроке я постараюсь коротко и понятно объяснить
что это такое, и в чем разница.

Вся информация в компьютере хранится в памяти (она бывает разной, но детали опустим), хранится она по условным ячейкам,
у каждой из которых есть свой адрес – собственно по этому адресу программа понимает, куда данные записывать, и от куда 
их потом получать.

Т.е., если мы где-то хотим сохранить `a := 500`, то в памяти будет найдена свободная ячейка памяти, и в эту ячейку будет
записано 500.

В go увидеть эту разницу легко. Напишите код:

```
func main() {
    i := 5

    fmt.Println("initial i:", i)
    fmt.Println("pointer:", &i)
}
```

Выполнив его вы увидите (номер ячейки памяти в вашем случае может отличаться):

```
$ go run pointers.go 
initial i: 5
pointer: 0xc000014108
```

Наглядно видно, что данные переменной `i` и указатель переменной `i` это разные вещи.

Теперь переходим к механике работы с указателями в Go. Если вы передаете в функцию переменную, равной 5, то по-умолчанию
передадутся сами данные. При этом с `i` и её значением вне функции ничего не изменится - потому что число 5 как 
хранилось в ячейке `0xc000014108` так там и хранится.

Давайте в этом убедимся. Дополним код следующим образом:

```
func no_link(i int) {
    fmt.Println("Start no_link() function - value:", i)
    i = 0
    fmt.Println("End no_link() function - value:", i)
    fmt.Println("no_link() function i pointer:", &i)
}

func main() {
    i := 5

    fmt.Println("initial i:", i)
    fmt.Println("pointer:", &i)

    no_link(i)
    fmt.Println("no_link(i):", i)
}
```

И выполним этот код:

```
$ go run pointers.go 
initial i: 5
pointer: 0xc0000b8010
Start no_link() function - value: 5
End no_link() function - value: 0
no_link() function i pointer: 0xc0000b8018
no_link(i): 5
```

Теперь разберем по шагам, что происходит:

- В функции `main` мы объявили переменную `i` и записали в неё значение `5`
- Затем мы переменную `i` передали в функцию `no_link()`. По умолчанию передалось ЗНАЧЕНИЕ переменной
- Вначале значение `i` (которая, хоть и называется также, как и переменная в функции `main`, но на самом деле это уже
другая, полностью независимая переменная) в функции `no_link()` была равна `5`, потому что такое значение было получено,
а затем оно было переписано на `0`
- После вызова функции `no_link()` мы еще раз выводим значение `i` в функции `main()` и видим, что значение как было
 равно `5` так и осталось.

Обратите внимание, что указатели `i` в `main()` и в `no_link()` имеют разное значение – т.е. это разные ячейки. Логично,
что изменение данных в одной ячейке, не затрагивает данные в другой ячейке.

Теперь, когда мы разобрались с тем, как работают переменные по-умолчанию, разберемся что значит работать с указателем.

Дополните код следующим образом:

```
func no_link(i int) {
    fmt.Println("Start no_link() function - value:", i)
    i = 0
    fmt.Println("End no_link() function - value:", i)
    fmt.Println("no_link() function i pointer:", &i)
}

func is_link(i *int) {
    fmt.Println("Start is_link() function - value:", i)
    *i = 0
    fmt.Println("End is_link() function - value:", i)
    fmt.Println("is_link() function i pointer:", &i)
}

func main() {
    i := 5

    fmt.Println("initial i:", i)
    fmt.Println("pointer:", &i)

//     no_link(i)
//     fmt.Println("no_link(i):", i)

    is_link(&i)

    fmt.Println("is_link(i):", i)
    fmt.Println("pointer:", &i)
}
```

Выполнив его получим:

```
$ go run pointers.go 
initial i: 5
pointer: 0xc00018c000
Start is_link() function - value: 0xc00018c000
End is_link() function - value: 0xc00018c000
is_link() function i pointer: 0xc000182020
is_link(i): 0
pointer: 0xc00018c000
```

Рассмотрим по шагам этот вариант:

- В функции `main` мы объявили переменную `i` и записали в неё значение `5`
- Затем мы переменную `i` передали в функцию `is_link()` как ссылку: указав в функции `*int` и передав переменную как 
`&i` – с помощью этого специального синтаксиса мы указываем go, что передаем именно ссылку, и работать внутри функции
будем с ссылкой.
- Внутри функции `is_link()` мы в переданную ссылку на ячейку памяти записываем `0`. Обратите внимание, что попытки
получить значение переменной не приводят ни к чему – мы получаем номер ячейки памяти и все.
- После вызова функции `is_link()` мы еще раз выводим значение `i` в функции `main()` и видим, что значение изменилось
на `0`. 

Почему так произошло? Потому что внутри функции `is_link()` мы работали с той же ячейкой памяти, что и в функции
`main()`, и это наглядно видно – её номер везде одинаковый.

____

В этом уроке вы узнали:

1. Чем отличаются данные от указателя на данные
2. Как работать с указателем в Go
